{"ast":null,"code":"/*\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, fromEnum, toEnum, markType } from \"igniteui-react-core\";\nimport { PathFigure } from \"igniteui-react-core\";\nimport { PathGeometry } from \"igniteui-react-core\";\nimport { NaNSegmenter } from \"./NaNSegmenter\";\nimport { PolyLineSegment } from \"igniteui-react-core\";\n/**\n * @hidden\n */\n\nvar PathRenderer =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(PathRenderer, _super);\n\n  function PathRenderer(a) {\n    var _rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      _rest[_i - 1] = arguments[_i];\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.a = null;\n    _this.b = 0;\n    a = a == void 0 ? 0 : a;\n\n    switch (a) {\n      case 0:\n        {\n          _this.b = 1;\n        }\n        break;\n\n      case 1:\n        {\n          var c = _rest[0];\n          _this.a = c;\n        }\n        break;\n    }\n\n    return _this;\n  }\n\n  PathRenderer.prototype.d = function (a, b, c) {\n    var e_1, _a;\n\n    var d = NaNSegmenter.c(b, this.b);\n    var e = this.c(d, c);\n    var f = new PathGeometry();\n\n    try {\n      for (var _b = tslib_1.__values(fromEnum(e)), _d = _b.next(); !_d.done; _d = _b.next()) {\n        var g = _d.value;\n        f.c.add(g);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    a.ak = f;\n  };\n\n  PathRenderer.prototype._c = function (a, b) {\n    var c, d, e, f, g;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          c = 0;\n          _a.label = 1;\n\n        case 1:\n          if (!(c < a.count)) return [3\n          /*break*/\n          , 4];\n          d = a.item(c);\n          if (!(d.count >= 2)) return [3\n          /*break*/\n          , 3];\n          e = new PathFigure();\n          f = d.item(0);\n          e._startPoint = f;\n          g = this.e(d, b);\n\n          e._segments.add(g);\n\n          return [4\n          /*yield*/\n          , e];\n\n        case 2:\n          _a.sent();\n\n          _a.label = 3;\n\n        case 3:\n          c++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  PathRenderer.prototype.c = function (a, b) {\n    var _this = this;\n\n    return toEnum(function () {\n      return _this._c(a, b);\n    });\n  };\n\n  PathRenderer.prototype.e = function (a, b) {\n    var c = new PolyLineSegment();\n\n    if (this.a == null) {\n      for (var d = 1; d < a.count; d++) {\n        var e = a.item(d);\n\n        c._points.add(e);\n      }\n    } else {\n      var f = this.a.flatten(a, b);\n\n      for (var g = 1; g < f.count; g++) {\n        var h = f.item(g);\n\n        c._points.add(h);\n      }\n    }\n\n    return c;\n  };\n\n  PathRenderer.$t = markType(PathRenderer, 'PathRenderer');\n  return PathRenderer;\n}(Base);\n\nexport { PathRenderer };","map":{"version":3,"sources":["../../../../src/igniteui-charts/lib/PathRenderer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, fromEnum, toEnum, markType } from \"igniteui-react-core\";\nimport { PathFigure } from \"igniteui-react-core\";\nimport { PathGeometry } from \"igniteui-react-core\";\nimport { NaNSegmenter } from \"./NaNSegmenter\";\nimport { PolyLineSegment } from \"igniteui-react-core\";\n/**\n * @hidden\n */\nvar PathRenderer = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(PathRenderer, _super);\n    function PathRenderer(a) {\n        var _rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            _rest[_i - 1] = arguments[_i];\n        }\n        var _this = _super.call(this) || this;\n        _this.a = null;\n        _this.b = 0;\n        a = (a == void 0) ? 0 : a;\n        switch (a) {\n            case 0:\n                {\n                    _this.b = 1;\n                }\n                break;\n            case 1:\n                {\n                    var c = _rest[0];\n                    _this.a = c;\n                }\n                break;\n        }\n        return _this;\n    }\n    PathRenderer.prototype.d = function (a, b, c) {\n        var e_1, _a;\n        var d = NaNSegmenter.c(b, this.b);\n        var e = this.c(d, c);\n        var f = new PathGeometry();\n        try {\n            for (var _b = tslib_1.__values(fromEnum(e)), _d = _b.next(); !_d.done; _d = _b.next()) {\n                var g = _d.value;\n                f.c.add(g);\n            }\n        }\n        catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n        }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _b.return))\n                    _a.call(_b);\n            }\n            finally {\n                if (e_1)\n                    throw e_1.error;\n            }\n        }\n        a.ak = f;\n    };\n    PathRenderer.prototype._c = function (a, b) {\n        var c, d, e, f, g;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    c = 0;\n                    _a.label = 1;\n                case 1:\n                    if (!(c < a.count))\n                        return [3 /*break*/, 4];\n                    d = a.item(c);\n                    if (!(d.count >= 2))\n                        return [3 /*break*/, 3];\n                    e = new PathFigure();\n                    f = d.item(0);\n                    e._startPoint = f;\n                    g = this.e(d, b);\n                    e._segments.add(g);\n                    return [4 /*yield*/, e];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    c++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    };\n    PathRenderer.prototype.c = function (a, b) {\n        var _this = this;\n        return toEnum(function () { return _this._c(a, b); });\n    };\n    PathRenderer.prototype.e = function (a, b) {\n        var c = new PolyLineSegment();\n        if (this.a == null) {\n            for (var d = 1; d < a.count; d++) {\n                var e = a.item(d);\n                c._points.add(e);\n            }\n        }\n        else {\n            var f = this.a.flatten(a, b);\n            for (var g = 1; g < f.count; g++) {\n                var h = f.item(g);\n                c._points.add(h);\n            }\n        }\n        return c;\n    };\n    PathRenderer.$t = markType(PathRenderer, 'PathRenderer');\n    return PathRenderer;\n}(Base));\nexport { PathRenderer };\n//# sourceMappingURL=PathRenderer.js.map\n"]},"metadata":{},"sourceType":"module"}