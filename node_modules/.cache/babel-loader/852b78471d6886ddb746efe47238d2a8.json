{"ast":null,"code":"/*\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, fromEnum, Number_$type, Point_$type, typeCast, toEnum, markType } from \"igniteui-react-core\";\nimport { PathFigure } from \"igniteui-react-core\";\nimport { List$1 } from \"igniteui-react-core\";\nimport { LineSegment } from \"igniteui-react-core\";\nimport { DelegateClipper } from \"./DelegateClipper\";\nimport { Flattener } from \"igniteui-react-core\";\nimport { GeometryGroup } from \"igniteui-react-core\";\nimport { isNaN_ } from \"igniteui-react-core\";\n/**\n * @hidden\n */\n\nvar IndicatorRenderer =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(IndicatorRenderer, _super);\n\n  function IndicatorRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  IndicatorRenderer.h = function (a, b, c, d) {\n    var e_1, _c;\n\n    var e = new PathFigure();\n    var f = IndicatorRenderer.b(a, b, c, d);\n\n    var _loop_1 = function (g) {\n      e._segments.add(function () {\n        var $ret = new LineSegment(1);\n        $ret.c = g;\n        return $ret;\n      }());\n    };\n\n    try {\n      for (var _d = tslib_1.__values(fromEnum(f)), _e = _d.next(); !_e.done; _e = _d.next()) {\n        var g = _e.value;\n\n        _loop_1(g);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    e._startPoint = e._segments._inner[0].c;\n    return e;\n  };\n\n  IndicatorRenderer.g = function (a, b, c, d, e, f, g, h, i, j, k) {\n    var l = g.ak.c;\n    var m = h.ak.c;\n\n    if (a > 1) {\n      var n = new DelegateClipper(b, c, a, k);\n      b = n.c;\n      c = n.d;\n      a = n.e;\n    }\n\n    if (i == 1) {\n      var o = new List$1(Number_$type, 0);\n      var p = l;\n      var q = 0;\n      o.add(0);\n\n      for (var r = 0, s = 1; s < a; r = s++) {\n        var t = q;\n        var u = c(s) - c(r);\n\n        if (d && !isNaN_(u)) {\n          t = Math.sign(u);\n        }\n\n        if (t != 0 && t != q) {\n          p.add(IndicatorRenderer.h(o, b, c, j));\n          q = t;\n          p = q == 1 ? m : l;\n          o.clear();\n          o.add(r);\n        }\n\n        o.add(s);\n      }\n\n      p.add(IndicatorRenderer.h(o, b, c, j));\n    } else {\n      var v = new List$1(Number_$type, 0);\n      var w = l;\n      var x = 0;\n      v.add(0);\n\n      for (var y = 0, z = 1; z < a; y = z++) {\n        var aa = x;\n        var ab = c(z) - c(y);\n\n        if (d && !isNaN_(ab)) {\n          aa = Math.sign(ab);\n        }\n\n        if (aa != 0 && aa != x) {\n          if (v.count > 0) {\n            w.add(IndicatorRenderer.h(v, b, c, j));\n          }\n\n          x = aa;\n          w = x == 1 ? m : l;\n          v.clear();\n          v.add(y);\n        }\n\n        v.add(z);\n      }\n\n      if (v.count > 0) {\n        w.add(IndicatorRenderer.h(v, b, c, j));\n      }\n    }\n  };\n\n  IndicatorRenderer.e = function (a, b, c, d, e, f, g, h, i, j, k, l, m, n) {\n    var o = new List$1(List$1.$.specialize(Point_$type), 0);\n    var p = new List$1(List$1.$.specialize(Point_$type), 0);\n    var q = new List$1(List$1.$.specialize(Point_$type), 0);\n    var r = new List$1(List$1.$.specialize(Point_$type), 0);\n\n    if (a <= 1) {\n      n = null;\n    }\n\n    k = Math.max(f.top, Math.min(f.bottom, k));\n\n    if (l == 1) {\n      var s = new List$1(Number_$type, 0);\n      var t = o;\n      var u = p;\n      var v = 0;\n      s.add(0);\n\n      for (var w = 0, x = 1; x < a; w = x++) {\n        var y = v;\n        var z = c(x) - c(w);\n\n        if (d && !isNaN_(z)) {\n          y = Math.sign(z);\n        }\n\n        if (y != 0 && y != v) {\n          if (s.count > 0) {\n            var aa = new List$1(Point_$type, 1, IndicatorRenderer.b(s, b, c, m));\n            var ab = new List$1(Point_$type, 1, aa);\n            ab.add({\n              $type: Point_$type,\n              x: aa._inner[aa.count - 1].x,\n              y: k\n            });\n            ab.add({\n              $type: Point_$type,\n              x: aa._inner[0].x,\n              y: k\n            });\n            t.add(aa);\n            u.add(ab);\n          }\n\n          v = y;\n          t = v == 1 ? q : o;\n          u = v == 1 ? r : p;\n          s.clear();\n          s.add(w);\n        }\n\n        s.add(x);\n      }\n\n      var ac = new List$1(Point_$type, 1, IndicatorRenderer.b(s, b, c, m));\n      var ad = new List$1(Point_$type, 1, ac);\n      ad.add({\n        $type: Point_$type,\n        x: ac._inner[ac.count - 1].x,\n        y: k\n      });\n      ad.add({\n        $type: Point_$type,\n        x: ac._inner[0].x,\n        y: k\n      });\n      t.add(ac);\n      u.add(ad);\n    } else {\n      var ae = new List$1(Number_$type, 0);\n      var af = o;\n      var ag = p;\n      var ah = 0;\n      ae.add(0);\n\n      for (var ai = 0, aj = 1; aj < a; ai = aj++) {\n        var ak = ah;\n        var al = c(aj) - c(ai);\n\n        if (d && !isNaN_(al)) {\n          ak = Math.sign(al);\n        }\n\n        if (ak != 0 && ak != ah) {\n          if (ae.count > 0) {\n            var am = new List$1(Point_$type, 1, IndicatorRenderer.b(ae, b, c, m));\n            var an = new List$1(Point_$type, 1, am);\n            an.add({\n              $type: Point_$type,\n              x: am._inner[am.count - 1].x,\n              y: k\n            });\n            an.add({\n              $type: Point_$type,\n              x: am._inner[0].x,\n              y: k\n            });\n            af.add(am);\n            ag.add(an);\n          }\n\n          ah = ak;\n          af = ah == 1 ? q : o;\n          ag = ah == 1 ? r : p;\n          ae.clear();\n          ae.add(ai);\n        }\n\n        ae.add(aj);\n      }\n\n      var ao = new List$1(Point_$type, 1, IndicatorRenderer.b(ae, b, c, m));\n      var ap = new List$1(Point_$type, 1, ao);\n      ap.add({\n        $type: Point_$type,\n        x: ao._inner[ao.count - 1].x,\n        y: k\n      });\n      ap.add({\n        $type: Point_$type,\n        x: ao._inner[0].x,\n        y: k\n      });\n      af.add(ao);\n      ag.add(ap);\n    }\n\n    if (n != null) {\n      o = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), o, function (aq) {\n        return IndicatorRenderer.c(n, aq, false);\n      }));\n      p = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), p, function (aq) {\n        return IndicatorRenderer.c(n, aq, true);\n      }));\n      q = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), q, function (aq) {\n        return IndicatorRenderer.c(n, aq, false);\n      }));\n      r = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), r, function (aq) {\n        return IndicatorRenderer.c(n, aq, true);\n      }));\n    }\n\n    var aq = g.ak.c;\n    var ar = h.ak.c;\n    var as = i.ak.c;\n    var at = j.ak.c;\n    IndicatorRenderer.d(aq, o);\n    IndicatorRenderer.d(ar, p);\n    IndicatorRenderer.d(as, q);\n    IndicatorRenderer.d(at, r);\n  };\n\n  IndicatorRenderer.f = function (a, b, c, d, e, f, g, h, i) {\n    var j = typeCast(GeometryGroup.$, h.ak);\n    var k = typeCast(GeometryGroup.$, i.ak);\n    var l = c;\n    var m = b;\n\n    var n = function (o) {\n      return Math.max(e.left, Math.min(e.right, o));\n    };\n\n    var o = function (p) {\n      return Math.max(e.top, Math.min(e.bottom, p));\n    };\n\n    b = function (p) {\n      return n(m(p));\n    };\n\n    c = function (p) {\n      return o(l(p));\n    };\n\n    f = o(f);\n\n    for (var p = 0; p < a; ++p) {\n      var q = g.item(p);\n      q.d = {\n        $type: Point_$type,\n        x: b(p),\n        y: f\n      };\n      q.c = {\n        $type: Point_$type,\n        x: b(p),\n        y: c(p)\n      };\n      var r = false;\n\n      if (p > 0) {\n        if (c(p) <= c(p - 1)) {\n          r = true;\n        }\n      } else {\n        if (a > 1) {\n          if (c(p + 1) <= c(p)) {\n            r = true;\n          }\n        }\n      }\n\n      if (r) {\n        j.d.add(q);\n      } else {\n        k.d.add(q);\n      }\n    }\n\n    g.count = a;\n  };\n\n  IndicatorRenderer._b = function (a, b, c, d) {\n    var e, f, g;\n    return tslib_1.__generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          e = Flattener.a(new List$1(Number_$type, 0), a, b, c, 0, a.count - 1, d);\n          f = 0;\n          _c.label = 1;\n\n        case 1:\n          if (!(f < e.count)) return [3\n          /*break*/\n          , 4];\n          g = e.item(f);\n          return [4\n          /*yield*/\n          , {\n            $type: Point_$type,\n            x: b(g),\n            y: c(g)\n          }];\n\n        case 2:\n          _c.sent();\n\n          _c.label = 3;\n\n        case 3:\n          f++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  IndicatorRenderer.b = function (a, b, c, d) {\n    return toEnum(function () {\n      return IndicatorRenderer._b(a, b, c, d);\n    });\n  };\n\n  IndicatorRenderer.d = function (a, b) {\n    var e_2, _c;\n\n    var _loop_2 = function (c) {\n      var e_3, _c;\n\n      if (c.count == 0) {\n        return \"continue\";\n      }\n\n      var d = function () {\n        var $ret = new PathFigure();\n        $ret.startPoint = c._inner[0];\n        return $ret;\n      }();\n\n      var _loop_3 = function (e) {\n        d._segments.add(function () {\n          var $ret = new LineSegment(1);\n          $ret.c = e;\n          return $ret;\n        }());\n      };\n\n      try {\n        for (var _d = (e_3 = void 0, tslib_1.__values(fromEnum(c))), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var e = _e.value;\n\n          _loop_3(e);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      a.add(d);\n    };\n\n    try {\n      for (var _d = tslib_1.__values(fromEnum(b)), _e = _d.next(); !_e.done; _e = _d.next()) {\n        var c = _e.value;\n\n        _loop_2(c);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  IndicatorRenderer.c = function (a, b, c) {\n    var d = a.f;\n    a.f = c;\n    var e = new List$1(Point_$type, 0);\n    a.i = e;\n    a.k(b, false);\n    a.i = null;\n    a.f = d;\n    return e;\n  };\n\n  IndicatorRenderer._a = function ($tSource, $tResult, a, b) {\n    var _c, _d, c, e_4_1;\n\n    var e_4, _e;\n\n    return tslib_1.__generator(this, function (_f) {\n      switch (_f.label) {\n        case 0:\n          _f.trys.push([0, 5, 6, 7]);\n\n          _c = tslib_1.__values(fromEnum(a)), _d = _c.next();\n          _f.label = 1;\n\n        case 1:\n          if (!!_d.done) return [3\n          /*break*/\n          , 4];\n          c = _d.value;\n          return [4\n          /*yield*/\n          , b(c)];\n\n        case 2:\n          _f.sent();\n\n          _f.label = 3;\n\n        case 3:\n          _d = _c.next();\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          return [3\n          /*break*/\n          , 7];\n\n        case 5:\n          e_4_1 = _f.sent();\n          e_4 = {\n            error: e_4_1\n          };\n          return [3\n          /*break*/\n          , 7];\n\n        case 6:\n          try {\n            if (_d && !_d.done && (_e = _c.return)) _e.call(_c);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 7:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  };\n\n  IndicatorRenderer.a = function ($tSource, $tResult, a, b) {\n    return toEnum(function () {\n      return IndicatorRenderer._a($tSource, $tResult, a, b);\n    });\n  };\n\n  IndicatorRenderer.$t = markType(IndicatorRenderer, 'IndicatorRenderer');\n  return IndicatorRenderer;\n}(Base);\n\nexport { IndicatorRenderer };","map":{"version":3,"sources":["../../../../src/igniteui-charts/lib/IndicatorRenderer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\nTHIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT (\"AGREEMENT\") LOCATED HERE:\nhttps://www.infragistics.com/legal/license/igultimate-la\nhttps://www.infragistics.com/legal/license/igultimate-eula\nGOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.\n*/\nimport * as tslib_1 from \"tslib\";\nimport { Base, fromEnum, Number_$type, Point_$type, typeCast, toEnum, markType } from \"igniteui-react-core\";\nimport { PathFigure } from \"igniteui-react-core\";\nimport { List$1 } from \"igniteui-react-core\";\nimport { LineSegment } from \"igniteui-react-core\";\nimport { DelegateClipper } from \"./DelegateClipper\";\nimport { Flattener } from \"igniteui-react-core\";\nimport { GeometryGroup } from \"igniteui-react-core\";\nimport { isNaN_ } from \"igniteui-react-core\";\n/**\n * @hidden\n */\nvar IndicatorRenderer = /** @class */ /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(IndicatorRenderer, _super);\n    function IndicatorRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IndicatorRenderer.h = function (a, b, c, d) {\n        var e_1, _c;\n        var e = new PathFigure();\n        var f = IndicatorRenderer.b(a, b, c, d);\n        var _loop_1 = function (g) {\n            e._segments.add(((function () {\n                var $ret = new LineSegment(1);\n                $ret.c = g;\n                return $ret;\n            })()));\n        };\n        try {\n            for (var _d = tslib_1.__values(fromEnum(f)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var g = _e.value;\n                _loop_1(g);\n            }\n        }\n        catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n        }\n        finally {\n            try {\n                if (_e && !_e.done && (_c = _d.return))\n                    _c.call(_d);\n            }\n            finally {\n                if (e_1)\n                    throw e_1.error;\n            }\n        }\n        e._startPoint = e._segments._inner[0].c;\n        return e;\n    };\n    IndicatorRenderer.g = function (a, b, c, d, e, f, g, h, i, j, k) {\n        var l = g.ak.c;\n        var m = h.ak.c;\n        if (a > 1) {\n            var n = new DelegateClipper(b, c, a, k);\n            b = n.c;\n            c = n.d;\n            a = n.e;\n        }\n        if (i == 1) {\n            var o = new List$1(Number_$type, 0);\n            var p = l;\n            var q = 0;\n            o.add(0);\n            for (var r = 0, s = 1; s < a; r = s++) {\n                var t = q;\n                var u = c(s) - c(r);\n                if (d && !isNaN_(u)) {\n                    t = Math.sign(u);\n                }\n                if (t != 0 && t != q) {\n                    p.add(IndicatorRenderer.h(o, b, c, j));\n                    q = t;\n                    p = q == 1 ? m : l;\n                    o.clear();\n                    o.add(r);\n                }\n                o.add(s);\n            }\n            p.add(IndicatorRenderer.h(o, b, c, j));\n        }\n        else {\n            var v = new List$1(Number_$type, 0);\n            var w = l;\n            var x = 0;\n            v.add(0);\n            for (var y = 0, z = 1; z < a; y = z++) {\n                var aa = x;\n                var ab = c(z) - c(y);\n                if (d && !isNaN_(ab)) {\n                    aa = Math.sign(ab);\n                }\n                if (aa != 0 && aa != x) {\n                    if (v.count > 0) {\n                        w.add(IndicatorRenderer.h(v, b, c, j));\n                    }\n                    x = aa;\n                    w = x == 1 ? m : l;\n                    v.clear();\n                    v.add(y);\n                }\n                v.add(z);\n            }\n            if (v.count > 0) {\n                w.add(IndicatorRenderer.h(v, b, c, j));\n            }\n        }\n    };\n    IndicatorRenderer.e = function (a, b, c, d, e, f, g, h, i, j, k, l, m, n) {\n        var o = new List$1(List$1.$.specialize(Point_$type), 0);\n        var p = new List$1(List$1.$.specialize(Point_$type), 0);\n        var q = new List$1(List$1.$.specialize(Point_$type), 0);\n        var r = new List$1(List$1.$.specialize(Point_$type), 0);\n        if (a <= 1) {\n            n = null;\n        }\n        k = Math.max(f.top, Math.min(f.bottom, k));\n        if (l == 1) {\n            var s = new List$1(Number_$type, 0);\n            var t = o;\n            var u = p;\n            var v = 0;\n            s.add(0);\n            for (var w = 0, x = 1; x < a; w = x++) {\n                var y = v;\n                var z = c(x) - c(w);\n                if (d && !isNaN_(z)) {\n                    y = Math.sign(z);\n                }\n                if (y != 0 && y != v) {\n                    if (s.count > 0) {\n                        var aa = new List$1(Point_$type, 1, IndicatorRenderer.b(s, b, c, m));\n                        var ab = new List$1(Point_$type, 1, aa);\n                        ab.add({ $type: Point_$type, x: aa._inner[aa.count - 1].x, y: k });\n                        ab.add({ $type: Point_$type, x: aa._inner[0].x, y: k });\n                        t.add(aa);\n                        u.add(ab);\n                    }\n                    v = y;\n                    t = v == 1 ? q : o;\n                    u = v == 1 ? r : p;\n                    s.clear();\n                    s.add(w);\n                }\n                s.add(x);\n            }\n            var ac = new List$1(Point_$type, 1, IndicatorRenderer.b(s, b, c, m));\n            var ad = new List$1(Point_$type, 1, ac);\n            ad.add({ $type: Point_$type, x: ac._inner[ac.count - 1].x, y: k });\n            ad.add({ $type: Point_$type, x: ac._inner[0].x, y: k });\n            t.add(ac);\n            u.add(ad);\n        }\n        else {\n            var ae = new List$1(Number_$type, 0);\n            var af = o;\n            var ag = p;\n            var ah = 0;\n            ae.add(0);\n            for (var ai = 0, aj = 1; aj < a; ai = aj++) {\n                var ak = ah;\n                var al = c(aj) - c(ai);\n                if (d && !isNaN_(al)) {\n                    ak = Math.sign(al);\n                }\n                if (ak != 0 && ak != ah) {\n                    if (ae.count > 0) {\n                        var am = new List$1(Point_$type, 1, IndicatorRenderer.b(ae, b, c, m));\n                        var an = new List$1(Point_$type, 1, am);\n                        an.add({ $type: Point_$type, x: am._inner[am.count - 1].x, y: k });\n                        an.add({ $type: Point_$type, x: am._inner[0].x, y: k });\n                        af.add(am);\n                        ag.add(an);\n                    }\n                    ah = ak;\n                    af = ah == 1 ? q : o;\n                    ag = ah == 1 ? r : p;\n                    ae.clear();\n                    ae.add(ai);\n                }\n                ae.add(aj);\n            }\n            var ao = new List$1(Point_$type, 1, IndicatorRenderer.b(ae, b, c, m));\n            var ap = new List$1(Point_$type, 1, ao);\n            ap.add({ $type: Point_$type, x: ao._inner[ao.count - 1].x, y: k });\n            ap.add({ $type: Point_$type, x: ao._inner[0].x, y: k });\n            af.add(ao);\n            ag.add(ap);\n        }\n        if (n != null) {\n            o = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), o, function (aq) { return IndicatorRenderer.c(n, aq, false); }));\n            p = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), p, function (aq) { return IndicatorRenderer.c(n, aq, true); }));\n            q = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), q, function (aq) { return IndicatorRenderer.c(n, aq, false); }));\n            r = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), r, function (aq) { return IndicatorRenderer.c(n, aq, true); }));\n        }\n        var aq = g.ak.c;\n        var ar = h.ak.c;\n        var as = i.ak.c;\n        var at = j.ak.c;\n        IndicatorRenderer.d(aq, o);\n        IndicatorRenderer.d(ar, p);\n        IndicatorRenderer.d(as, q);\n        IndicatorRenderer.d(at, r);\n    };\n    IndicatorRenderer.f = function (a, b, c, d, e, f, g, h, i) {\n        var j = typeCast(GeometryGroup.$, h.ak);\n        var k = typeCast(GeometryGroup.$, i.ak);\n        var l = c;\n        var m = b;\n        var n = function (o) { return Math.max(e.left, Math.min(e.right, o)); };\n        var o = function (p) { return Math.max(e.top, Math.min(e.bottom, p)); };\n        b = function (p) { return n(m(p)); };\n        c = function (p) { return o(l(p)); };\n        f = o(f);\n        for (var p = 0; p < a; ++p) {\n            var q = g.item(p);\n            q.d = { $type: Point_$type, x: b(p), y: f };\n            q.c = { $type: Point_$type, x: b(p), y: c(p) };\n            var r = false;\n            if (p > 0) {\n                if (c(p) <= c(p - 1)) {\n                    r = true;\n                }\n            }\n            else {\n                if (a > 1) {\n                    if (c(p + 1) <= c(p)) {\n                        r = true;\n                    }\n                }\n            }\n            if (r) {\n                j.d.add(q);\n            }\n            else {\n                k.d.add(q);\n            }\n        }\n        g.count = a;\n    };\n    IndicatorRenderer._b = function (a, b, c, d) {\n        var e, f, g;\n        return tslib_1.__generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    e = Flattener.a(new List$1(Number_$type, 0), a, b, c, 0, a.count - 1, d);\n                    f = 0;\n                    _c.label = 1;\n                case 1:\n                    if (!(f < e.count))\n                        return [3 /*break*/, 4];\n                    g = e.item(f);\n                    return [4 /*yield*/, { $type: Point_$type, x: b(g), y: c(g) }];\n                case 2:\n                    _c.sent();\n                    _c.label = 3;\n                case 3:\n                    f++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    };\n    IndicatorRenderer.b = function (a, b, c, d) {\n        return toEnum(function () { return IndicatorRenderer._b(a, b, c, d); });\n    };\n    IndicatorRenderer.d = function (a, b) {\n        var e_2, _c;\n        var _loop_2 = function (c) {\n            var e_3, _c;\n            if (c.count == 0) {\n                return \"continue\";\n            }\n            var d = ((function () {\n                var $ret = new PathFigure();\n                $ret.startPoint = c._inner[0];\n                return $ret;\n            })());\n            var _loop_3 = function (e) {\n                d._segments.add(((function () {\n                    var $ret = new LineSegment(1);\n                    $ret.c = e;\n                    return $ret;\n                })()));\n            };\n            try {\n                for (var _d = (e_3 = void 0, tslib_1.__values(fromEnum(c))), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var e = _e.value;\n                    _loop_3(e);\n                }\n            }\n            catch (e_3_1) {\n                e_3 = { error: e_3_1 };\n            }\n            finally {\n                try {\n                    if (_e && !_e.done && (_c = _d.return))\n                        _c.call(_d);\n                }\n                finally {\n                    if (e_3)\n                        throw e_3.error;\n                }\n            }\n            a.add(d);\n        };\n        try {\n            for (var _d = tslib_1.__values(fromEnum(b)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var c = _e.value;\n                _loop_2(c);\n            }\n        }\n        catch (e_2_1) {\n            e_2 = { error: e_2_1 };\n        }\n        finally {\n            try {\n                if (_e && !_e.done && (_c = _d.return))\n                    _c.call(_d);\n            }\n            finally {\n                if (e_2)\n                    throw e_2.error;\n            }\n        }\n    };\n    IndicatorRenderer.c = function (a, b, c) {\n        var d = a.f;\n        a.f = c;\n        var e = new List$1(Point_$type, 0);\n        a.i = e;\n        a.k(b, false);\n        a.i = null;\n        a.f = d;\n        return e;\n    };\n    IndicatorRenderer._a = function ($tSource, $tResult, a, b) {\n        var _c, _d, c, e_4_1;\n        var e_4, _e;\n        return tslib_1.__generator(this, function (_f) {\n            switch (_f.label) {\n                case 0:\n                    _f.trys.push([0, 5, 6, 7]);\n                    _c = tslib_1.__values(fromEnum(a)), _d = _c.next();\n                    _f.label = 1;\n                case 1:\n                    if (!!_d.done)\n                        return [3 /*break*/, 4];\n                    c = _d.value;\n                    return [4 /*yield*/, b(c)];\n                case 2:\n                    _f.sent();\n                    _f.label = 3;\n                case 3:\n                    _d = _c.next();\n                    return [3 /*break*/, 1];\n                case 4: return [3 /*break*/, 7];\n                case 5:\n                    e_4_1 = _f.sent();\n                    e_4 = { error: e_4_1 };\n                    return [3 /*break*/, 7];\n                case 6:\n                    try {\n                        if (_d && !_d.done && (_e = _c.return))\n                            _e.call(_c);\n                    }\n                    finally {\n                        if (e_4)\n                            throw e_4.error;\n                    }\n                    return [7 /*endfinally*/];\n                case 7: return [2 /*return*/];\n            }\n        });\n    };\n    IndicatorRenderer.a = function ($tSource, $tResult, a, b) {\n        return toEnum(function () { return IndicatorRenderer._a($tSource, $tResult, a, b); });\n    };\n    IndicatorRenderer.$t = markType(IndicatorRenderer, 'IndicatorRenderer');\n    return IndicatorRenderer;\n}(Base));\nexport { IndicatorRenderer };\n//# sourceMappingURL=IndicatorRenderer.js.map\n"]},"metadata":{},"sourceType":"module"}